import json
import os
import time
from langchain_google_genai import ChatGoogleGenerativeAI
from dotenv import load_dotenv

load_dotenv()

def generate_exploit_plan(batch_size=5, delay_seconds=7):
    """
    Generate exploit plans for vulnerabilities found in RL training data.
    
    Args:
        batch_size: Number of vulnerabilities to process in each batch (default: 5)
        delay_seconds: Delay between API requests in seconds (default: 7, to stay under 10/min quota)
    """
    # 1. Load the "Training Data" (The Artifact)
    if not os.path.exists("rl_training_data.json"):
        print("No training data found. Run the QA Agent first.")
        return

    with open("rl_training_data.json", "r") as f:
        trajectory = json.load(f)

    # 2. Filter for "Interesting" States (High Reward) and deduplicate
    vulnerabilities = []
    seen = set()
    for t in trajectory:
        if t["reward"] >= 0.5:
            # Create a unique key based on action + target
            target = t.get("target", {})
            key = (t["action"], target.get("tagName"), target.get("outerHTML", ""))
            if key not in seen:
                seen.add(key)
                vulnerabilities.append(t)

    if not vulnerabilities:
        print("No vulnerabilities found in the training run.")
        return

    print(f"Found {len(vulnerabilities)} unique potential vulnerability points.")
    print(f"Processing in batches of {batch_size} with {delay_seconds}s delay between requests.\n")

    # 3. Formulate the Plan using Gemini
    model = ChatGoogleGenerativeAI(
        model="gemini-2.0-flash-exp",
        api_key=os.getenv("GOOGLE_API_KEY"),
        temperature=0.2
    )

    # 4. Store all generated exploits
    exploit_plans = []
    
    # 5. Process vulnerabilities in batches
    total_batches = (len(vulnerabilities) + batch_size - 1) // batch_size
    
    for batch_idx in range(total_batches):
        start_idx = batch_idx * batch_size
        end_idx = min(start_idx + batch_size, len(vulnerabilities))
        batch = vulnerabilities[start_idx:end_idx]
        
        print(f"\n{'='*60}")
        print(f"Processing Batch {batch_idx + 1}/{total_batches} (items {start_idx+1}-{end_idx})")
        print(f"{'='*60}\n")
        
        for idx, vuln in enumerate(batch, start=1):
            target = vuln.get("target", {})
            
            prompt = f"""
            You are an Elite Penetration Tester. 
            
            We previously ran a fuzzing scan and found a vulnerability (Reward: {vuln['reward']}).
            
            VULNERABLE ELEMENT:
            - Tag: {target.get('tagName')}
            - ID: {target.get('id')}
            - Name: {target.get('name')}
            - HTML Context: {target.get('outerHTML')}
            
            ACTION THAT TRIGGERED IT:
            - Action Type: {vuln['action']}
            - Logs: {vuln['log']}
            - Reason for Detection: {vuln['reason']}
            
            YOUR TASK:
            Write a specific PLAYWRIGHT SCRIPT snippet to exploit this specific element.
            If it was an input, suggest an SQL Injection or XSS payload.
            If it was a crash, suggest a DoS payload.
            
            Return code only.
            """

            element_id = target.get('id', 'unknown') or target.get('tagName', 'unknown')
            print(f"[{start_idx + idx}/{len(vulnerabilities)}] Generating Exploit for {element_id}...")
            
            try:
                res = model.invoke(prompt)
                exploit_code = res.content
                
                # Store the exploit plan
                exploit_plan = {
                    "step": vuln.get("step"),
                    "reward": vuln.get("reward"),
                    "action": vuln.get("action"),
                    "target": target,
                    "log": vuln.get("log"),
                    "reason": vuln.get("reason"),
                    "exploit_code": exploit_code,
                    "element_id": element_id
                }
                exploit_plans.append(exploit_plan)
                
                print(f"âœ… Exploit generated successfully")
                print("-" * 40)
                
                # Add delay between requests (except for the last item in batch)
                if idx < len(batch):
                    print(f"â³ Waiting {delay_seconds} seconds before next request...")
                    time.sleep(delay_seconds)
                    
            except Exception as e:
                print(f"âŒ Error generating exploit: {str(e)}")
                # Store error information
                exploit_plan = {
                    "step": vuln.get("step"),
                    "reward": vuln.get("reward"),
                    "action": vuln.get("action"),
                    "target": target,
                    "log": vuln.get("log"),
                    "reason": vuln.get("reason"),
                    "exploit_code": None,
                    "error": str(e),
                    "element_id": element_id
                }
                exploit_plans.append(exploit_plan)
                
                # Wait longer on error (might be rate limit)
                if "quota" in str(e).lower() or "429" in str(e):
                    print(f"âš ï¸  Rate limit detected. Waiting {delay_seconds * 2} seconds...")
                    time.sleep(delay_seconds * 2)
                else:
                    time.sleep(delay_seconds)
        
        # Longer delay between batches
        if batch_idx < total_batches - 1:
            print(f"\nðŸ”„ Batch complete. Waiting {delay_seconds * 2} seconds before next batch...\n")
            time.sleep(delay_seconds * 2)
    
    # 6. Save all exploit plans to file
    output_file = "final_exploit_plan.json"
    with open(output_file, "w") as f:
        json.dump({
            "total_vulnerabilities": len(vulnerabilities),
            "total_exploits_generated": len(exploit_plans),
            "exploits": exploit_plans
        }, f, indent=2)
    
    print(f"\n{'='*60}")
    print(f"âœ… Successfully generated {len(exploit_plans)} exploit plans")
    print(f"ðŸ“„ Saved to: {output_file}")
    print(f"{'='*60}")

if __name__ == "__main__":
    generate_exploit_plan()