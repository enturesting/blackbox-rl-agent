import json
import os
import time
from langchain_google_genai import ChatGoogleGenerativeAI
from dotenv import load_dotenv

load_dotenv()

def generate_exploit_plan(delay_seconds=5):
    """
    Generates an exploit plan that includes the REFERENCE SCREENSHOT path
    so the Attack Agent can 'see' what the vulnerability looked like.
    
    Args:
        delay_seconds: Delay between API requests in seconds (default: 5)
    """
    if not os.path.exists("rl_training_data.json"):
        print("‚ùå No training data found.")
        return

    with open("rl_training_data.json", "r") as f:
        trajectory = json.load(f)

    # Filter for vulnerabilities
    vulnerabilities = []
    seen = set()
    for i, t in enumerate(trajectory):
        if t["reward"] >= 0.5:
            target = t.get("target", {})
            key = (t["action"], target.get("tagName"), target.get("outerHTML", ""))
            
            if key not in seen:
                seen.add(key)
                # CAPTURE HISTORY
                clean_history = [step for step in trajectory[:i] if step["reward"] >= 0]
                
                # CAPTURE SCREENSHOT PATH
                # QA Agent saves step_0.png, then increments step to 1. 
                # So if trajectory says step 1, the image is step_0.png.
                img_index = t["step"] - 1
                screenshot_path = f"qa_screenshots/step_{img_index}.png"
                
                if not os.path.exists(screenshot_path):
                    print(f"‚ö†Ô∏è Warning: Screenshot {screenshot_path} not found.")
                    screenshot_path = None

                t_with_data = t.copy()
                t_with_data["setup_steps"] = clean_history
                t_with_data["ref_screenshot"] = screenshot_path # <--- NEW
                vulnerabilities.append(t_with_data)

    print(f"üî• Found {len(vulnerabilities)} vulnerabilities with visual context.")

    # Generate Plans
    model = ChatGoogleGenerativeAI(
        model="gemini-2.0-flash-exp",
        api_key=os.getenv("GOOGLE_API_KEY"),
        temperature=0.2
    )

    exploit_plans = []
    
    for vuln in vulnerabilities:
        target = vuln.get("target", {})
        element_id = target.get('id', 'unknown') or target.get('tagName', 'unknown')
        
        print(f"   Generating plan for {element_id}...")
        
        # We just ask for the code snippet here, the visual matching happens in attack.py
        prompt = f"""
        Write a Python Playwright snippet to exploit this element:
        Tag: {target.get('tagName')}
        ID: {target.get('id')}
        HTML: {target.get('outerHTML')}
        Trigger: {vuln['log']}
        Return ONLY code.
        """
        
        try:
            res = model.invoke(prompt)
            exploit_plan = {
                "target": target,
                "action": vuln.get("action"),
                "log": vuln.get("log"),
                "reason": vuln.get("reason"),
                "exploit_code": res.content,
                "setup_steps": vuln["setup_steps"],
                "ref_screenshot": vuln["ref_screenshot"], # Pass it along
                "element_id": element_id
            }
            exploit_plans.append(exploit_plan)
            time.sleep(delay_seconds)
        except Exception as e:
            print(f"Error: {e}")

    with open("final_exploit_plan.json", "w") as f:
        json.dump({"exploits": exploit_plans}, f, indent=2)
    
    print(f"‚úÖ Saved {len(exploit_plans)} visual exploit plans.")

if __name__ == "__main__":
    generate_exploit_plan()